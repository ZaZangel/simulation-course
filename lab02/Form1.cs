// Подключение необходимых системных библиотек для работы приложения
using System;  // Базовые системные типы и функции
using System.Collections.Generic;  // Коллекции (списки, словари и т.д.)
using System.ComponentModel;  // Компоненты для работы с дизайнером форм
using System.Data;  // Работа с данными и базами данных
using System.Diagnostics;  // Диагностика: Stopwatch для замера времени
using System.Drawing;  // Работа с графикой, цветами, шрифтами
using System.Linq;  // LINQ-запросы для работы с коллекциями
using System.Text;  // Работа с текстом и кодировками
using System.Threading.Tasks;  // Асинхронное программирование
using System.Windows.Forms;  // Библиотека Windows Forms для создания GUI
using System.Windows.Forms.DataVisualization.Charting;  // Компоненты для построения графиков
using static System.Windows.Forms.VisualStyles.VisualStyleElement;  // Статические элементы визуальных стилей

// Объявление пространства имен проекта
namespace Lab2  
{
    public partial class Form1 : Form  // partial позволяет разделить код формы на несколько файлов
    {
        public Form1()
        {
            InitializeComponent();  // Метод, созданный дизайнером: инициализирует все элементы формы (кнопки, поля, график)
        }

        private void btnStart_Click(object sender, EventArgs e)  // sender — источник события, e — параметры события
        {
            // === ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ ДЛЯ ВХОДНЫХ ПАРАМЕТРОВ ===

            // Объявление переменных типа double для хранения числовых параметров
            double dt, t0, tl, tr, L, time, p, c, lambda, h;  // dt-шаг времени, t0-нач.температура, tl/tr-граничные темп., L-длина, time-общее время, p-плотность, c-теплоёмкость, lambda-теплопроводность, h-шаг пространства

            // Создание объекта Stopwatch для замера времени выполнения расчёта
            Stopwatch sw = new Stopwatch();  // sw — объект-секундомер из пространства System.Diagnostics


            // Чтение шага по времени из элемента inputDelta и преобразование в double
            dt = (double)inputDelta.Value;  // Шаг по времени Δt (в секундах) — определяет дискретизацию по времени

            // Чтение шага по пространству из элемента inputStep и преобразование в double
            h = (double)inputStep.Value;  // Шаг по пространству h (в метрах) — определяет дискретизацию по координате x

            // Чтение начальной температуры всей пластины
            t0 = (double)inputStartTemp.Value;  // Начальная температура T₀ во всех точках пластины в момент t=0

            // Чтение температуры на левой границе пластины (x=0)
            tl = (double)inputLeft.Value;  // Граничное условие: температура на левом крае

            // Чтение температуры на правой границе пластины (x=L)
            tr = (double)inputRight.Value;  // Граничное условие: температура на правом крае

            // Чтение толщины (длины) пластины
            L = (double)inputWidth.Value;  // Геометрический размер пластины в метрах

            // Чтение общего времени моделирования
            time = (double)inputTime.Value;  // Длительность процесса теплопроводности в секундах

            // Чтение плотности материала (например, стали ~7800 кг/м³)
            p = (double)inputPlot.Value;  // Плотность ρ (ро) — масса единицы объема, кг/м³

            // Чтение удельной теплоёмкости материала (например, стали ~460 Дж/(кг·K))
            c = (double)inputHeat.Value;  // Удельная теплоёмкость c — количество тепла для нагрева 1 кг на 1 K, Дж/(кг·K)

            // Чтение коэффициента теплопроводности материала (например, стали ~46 Вт/(м·K))
            lambda = (double)inputLambda.Value;  // Коэффициент теплопроводности λ (лямбда) — способность проводить тепло, Вт/(м·K)

            //РАСЧЁТ РАЗМЕРНОСТЕЙ СЕТКИ

            // Вычисление количества узлов сетки по пространству: L/h + 1 (включая обе границы)
            int N = (int)(L / h) + 1;  // N — количество точек дискретизации вдоль пластины (индексы 0...N-1)

            // Вычисление количества шагов по времени: общее время / шаг времени
            int M = (int)(time / dt);  // M — количество итераций временного цикла

            // ИНИЦИАЛИЗАЦИЯ МАССИВОВ ДЛЯ МЕТОДА ПРОГОНКИ

            // Создание массива для хранения значений температуры в каждом узле пространственной сетки
            double[] t = new double[N];  // t[i] — температура в i-м узле на текущем временном слое

            // Создание массива для коэффициентов α (альфа) метода прогонки
            double[] alpha = new double[N];  // alpha[i] — коэффициент при T[i+1] в рекуррентной формуле

            // Создание массива для коэффициентов β (бета) метода прогонки
            double[] beta = new double[N];  // beta[i] — свободный член в рекуррентной формуле

            // Объявление вспомогательных переменных для коэффициентов трёхдиагональной матрицы
            double Ai, Ci, Bi, Fi;  // Ai, Ci — поддиагональ и наддиагональ, Bi — главная диагональ, Fi — правая часть СЛАУ

            // Вычисление коэффициентов Ai и Ci (они равны из-за симметрии задачи)
            Ai = Ci = lambda / (h * h);  // Коэффициент при второй производной по x в конечно-разностной аппроксимации

            // Вычисление коэффициента Bi главной диагонали матрицы
            Bi = 2 * lambda / (h * h) + p * c / dt;  // Сумма коэффициента диффузии и коэффициента инерции по времени

            // ЗАДАНИЕ НАЧАЛЬНЫХ УСЛОВИЙ 

            // Цикл заполнения массива температуры начальным значением t0 во всех узлах
            for (int i = 0; i < N; i++)  // Проходим по всем пространственным узлам от 0 до N-1
            {
                t[i] = t0;  // Присваиваем начальную температуру каждому узлу сетки
            }  // Конец цикла инициализации

            // ЗАДАНИЕ ГРАНИЧНЫХ УСЛОВИЙ (условия Дирихле)

            // Установка температуры в левом граничном узле (x=0)
            t[0] = tl;  // Температура на левой границе фиксирована и равна tl

            // Установка температуры в правом граничном узле (x=L)
            t[t.Length - 1] = tr;  // Температура на правой границе фиксирована и равна tr (t.Length-1 = N-1)

            // Запуск секундомера для замера времени вычислений
            sw.Start();  // Начинаем отсчёт времени выполнения алгоритма

            // === ВРЕМЕННОЙ ЦИКЛ: расчёт на каждом шаге по времени ===

            // Цикл по всем временным шагам от 0 до M-1
            for (int step = 0; step < M; step++)  // Выполняем M итераций для продвижения по времени
            {
                // === ПРЯМОЙ ХОД МЕТОДА ПРОГОНКИ ===

                // Задание начальных коэффициентов прогонки для левого граничного узла
                alpha[0] = 0.0;  // Для граничного условия T[0]=tl коэффициент α[0] равен нулю

                beta[0] = tl;  // Для граничного условия T[0]=tl коэффициент β[0] равен значению границы

                // Цикл прямого хода: вычисление коэффициентов α и β для всех внутренних узлов
                for (int i = 1; i < N; i++)  // Проходим от второго узла (i=1) до последнего (i=N-1)
                {
                    // Вычисление коэффициента α[i] по рекуррентной формуле метода прогонки
                    alpha[i] = Ai / (Bi - Ci * alpha[i - 1]);  // Формула: αᵢ = Aᵢ / (Bᵢ - Cᵢ·αᵢ₋₁)

                    // Вычисление правой части уравнения Fi для текущего узла
                    Fi = -p * c * t[i] / dt;  // Fi = -ρ·c·Tᵢⁿ/Δt — вклад предыдущего временного слоя

                    // Вычисление коэффициента β[i] по рекуррентной формуле метода прогонки
                    beta[i] = (Ci * beta[i - 1] - Fi) / (Bi - Ci * alpha[i - 1]);  // Формула: βᵢ = (Cᵢ·βᵢ₋₁ - Fᵢ) / (Bᵢ - Cᵢ·αᵢ₋₁)
                }  // Конец цикла прямого хода

                // === ОБРАТНЫЙ ХОД МЕТОДА ПРОГОНКИ ===

                // Цикл обратного хода: вычисление значений температуры от предпоследнего узла к первому
                for (int i = N - 2; i > 0; i--)  // Идём от i=N-2 до i=1 (граничные узлы 0 и N-1 уже известны)
                {
                    // Вычисление температуры в узле i по формуле прогонки
                    t[i] = alpha[i] * t[i + 1] + beta[i];  // Формула: Tᵢ = αᵢ·Tᵢ₊₁ + βᵢ
                }  // Конец цикла обратного хода

                // === ОБНОВЛЕНИЕ ГРАФИКА ПОСЛЕ КАЖДОГО ВРЕМЕННОГО ШАГА ===

                // Очистка предыдущих точек графика перед отрисовкой новых данных
                chart1.Series[0].Points.Clear();  // Удаляем все точки из первой серии графика

                // Цикл добавления точек на график для визуализации распределения температуры
                for (int i = 0; i < N; i++)  // Проходим по всем пространственным узлам
                {
                    // Добавление точки на график: X = координата (i*h), Y = температура t[i]
                    chart1.Series[0].Points.AddXY(i * h, t[i]);  // AddXY(x, y) добавляет точку с координатами (x, y)
                }  // Конец цикла отрисовки

                // Настройка подписи и диапазона оси X графика
                chart1.ChartAreas[0].AxisX.Minimum = 0;  // Минимум оси X равен 0 (начало пластины)

                chart1.ChartAreas[0].AxisX.Maximum = L;  // Максимум оси X равен L (конец пластины)

                chart1.ChartAreas[0].AxisX.Title = "Координата x, м";  // Подпись оси X с указанием единицы измерения

                chart1.ChartAreas[0].AxisY.Title = "Температура T, °C";  // Подпись оси Y с указанием единицы измерения
            }  // Конец временного цикла (step)

            // Остановка секундомера после завершения всех вычислений
            sw.Stop();  // Останавливаем отсчёт времени

            // === ВЫЧИСЛЕНИЕ И ВЫВОД РЕЗУЛЬТАТОВ ===

            // Вычисление индекса центрального узла пластины (целочисленное деление)
            int centerIndex = N / 2;  // Например, при N=11 получим index=5 (шестой элемент)

            // Получение значения температуры в центральном узле
            double tCenter = t[centerIndex];  // Температура в середине пластины на последнем временном слое

            // Получение затраченного реального времени вычислений в секундах
            double realTime = sw.Elapsed.TotalSeconds;  // Elapsed — TimeSpan, TotalSeconds — время в секундах с дробной частью

            // Добавление строки с результатами в таблицу dataGridResults
            dataGridResults.Rows.Add(dt, h, tCenter, realTime);  // Добавляем: шаг времени, шаг пространства, T(центр), время расчёта
        }  // Конец обработчика btnStart_Click

        // Обработчик события Click для кнопки "Очистить" (btnClear)
        private void btnClear_Click(object sender, EventArgs e)  // Обработчик очистки таблицы результатов
        {
            // Очистка всех строк таблицы результатов
            dataGridResults.Rows.Clear();  // Удаляем все строки из DataGridView, оставляя заголовки столбцов
        }  // Конец обработчика btnClear_Click

        // Обработчик события Load формы (выполняется при загрузке формы)
        private void Form1_Load(object sender, EventArgs e)  // Пустой обработчик — можно добавить инициализацию при старте
        {
            // Пустое тело метода — при необходимости можно добавить код инициализации
        }  // Конец обработчика Form1_Load
    }  // Конец класса Form1
}  // Конец пространства имен Lab2